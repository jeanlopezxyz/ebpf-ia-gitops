# eBPF + IA: Detecci√≥n de Amenazas en Tiempo Real

## ¬øC√≥mo detectar ataques cibern√©ticos en tiempo real sin impactar el rendimiento?

Imagina un sistema que puede analizar **cada paquete de red** que pasa por tu infraestructura, detectar patrones sospechosos como ataques DDoS o escaneos de puertos, y alertarte en segundos - todo esto sin afectar la velocidad de tu red. Esto es exactamente lo que logra este proyecto combinando **eBPF** (observabilidad a nivel del kernel) con **Inteligencia Artificial**.

### El Problema que Resolvemos

Los sistemas tradicionales de seguridad enfrentan un dilema:
- **Monitoreo superficial**: R√°pido pero pierde detalles cr√≠ticos  
- **An√°lisis profundo**: Detecta todo pero ralentiza el sistema

Nuestra soluci√≥n rompe este compromiso usando eBPF para capturar datos a velocidad del kernel, y modelos de ML para detectar tanto amenazas conocidas como anomal√≠as nuevas.

### Arquitectura en 2 Minutos

El sistema tiene dos componentes principales que trabajan en conjunto:

1. **`ebpf-monitor`** (Go + eBPF): El "sensor" que captura tr√°fico de red
2. **`ml-detector`** (Python + Flask): El "cerebro" que analiza y decide

Todo se despliega autom√°ticamente via GitOps con ArgoCD y se monitorea con Prometheus/Grafana.

## Los Componentes en Acci√≥n

### üîç eBPF Monitor: El Sensor de Red Inteligente

**Ubicaci√≥n**: `applications/ebpf-monitor/`  
**Lenguaje**: Go + eBPF (C)  
**Puerto**: 8800  

Este es nuestro "radar" que nunca duerme. Aqu√≠ es donde la magia de eBPF sucede:

#### 1. Captura a Velocidad del Kernel
```go
// Estructura que replica exactamente el struct C del kernel
type NetworkEvent struct {
    SrcIP      uint32 // IP origen
    DstIP      uint32 // IP destino  
    SrcPort    uint16 // Puerto origen
    DstPort    uint16 // Puerto destino
    Protocol   uint8  // TCP/UDP/ICMP
    PacketSize uint32 // Tama√±o en bytes
    Timestamp  uint64 // Cu√°ndo ocurri√≥
    TCPFlags   uint8  // SYN, ACK, etc.
}
```

**¬øC√≥mo lo hace tan r√°pido?**
- El programa eBPF (en C) vive en el kernel y "ve" cada paquete
- Env√≠a eventos via ring buffer (canal ultrarr√°pido)
- Go consume eventos sin interrumpir el kernel

#### 2. Agregaci√≥n Inteligente por Ventanas
En lugar de procesar paquete por paquete, agrupa datos en "ventanas" de tiempo:

```
Ventana de 1 segundo:
‚îú‚îÄ‚îÄ 1,247 paquetes/seg
‚îú‚îÄ‚îÄ 987,432 bytes/seg  
‚îú‚îÄ‚îÄ 23 IPs √∫nicas
‚îú‚îÄ‚îÄ 15 puertos √∫nicos
‚îî‚îÄ‚îÄ 89 paquetes SYN
```

**Configuraci√≥n**: Variable `STATS_WINDOW` (por defecto 1s)

#### 3. API HTTP Rica en Informaci√≥n
- **`/health`**: ¬øEst√° vivo el monitor?
- **`/ready`**: ¬øeBPF funcionando o modo simulaci√≥n activo?
- **`/metrics`**: M√©tricas Prometheus para observabilidad
- **`/stats`**: Snapshot actual de estad√≠sticas

#### 4. Comunicaci√≥n con la IA
Cada `POST_INTERVAL` (2s por defecto), env√≠a un POST a `ml-detector`:

```json
{
  "packets_per_second": 1247,
  "bytes_per_second": 987432,
  "unique_ips": 23,
  "unique_ports": 15,
  "tcp_ratio": 0.85,
  "syn_packets": 89
}
```

#### 5. Modo de Emergencia
**Sin privilegios eBPF?** No hay problema - se activa **modo simulaci√≥n**:
- Genera datos sint√©ticos realistas
- Mantiene APIs funcionando
- Ideal para desarrollo y testing

### üß† ML Detector: El Cerebro que Decide

**Ubicaci√≥n**: `applications/ml-detector/`  
**Lenguaje**: Python + Flask + Scikit-learn  
**Puerto**: 5000  

Este es donde los datos se transforman en decisiones inteligentes. El detector combina **reglas expl√≠citas** con **modelos de machine learning** para detectar tanto amenazas conocidas como anomal√≠as nuevas.

#### 1. API Simple pero Poderosa

```python
# El endpoint principal
POST /detect
Content-Type: application/json

{
  "packets_per_second": 1200,
  "bytes_per_second": 1500000,
  "unique_ips": 30,
  "unique_ports": 50,
  "tcp_ratio": 0.95,
  "syn_packets": 800
}

# Respuesta con veredicto
{
  "threat_detected": true,
  "confidence": 0.87,
  "threat_types": ["port_scan", "ml_medium_risk"]
}
```

**Otros endpoints √∫tiles:**
- **`GET /detect/prom`**: Consulta Prometheus directamente y analiza
- **`/health`**: Estado del servicio y modelos
- **`/metrics`**: M√©tricas detalladas para Prometheus
- **`/train`**: Reentrenamiento manual de modelos

#### 2. Detecci√≥n H√≠brida: Reglas + IA

##### A) Reglas R√°pidas y Explicables
```python
thresholds = {
    "port_scan": {
        "unique_ports": 20,      # >20 puertos √∫nicos
        "packets_per_second": 100 # + alto PPS = sospechoso
    },
    "ddos": {
        "packets_per_second": 1000,   # >1000 PPS
        "bytes_per_second": 1_000_000 # + 1MB/s = posible DDoS
    },
    "syn_flood": {
        "syn_packets": 500,     # >500 SYNs/ventana
        "tcp_ratio": 0.95       # + 95% TCP = SYN flood
    }
}
```

##### B) Modelos ML para Anomal√≠as Desconocidas

**Ensamble de 3 algoritmos** que se complementan:

1. **MiniBatchKMeans** (Clustering)
   - **Prop√≥sito**: Define qu√© es "tr√°fico normal" con centros de clusters
   - **Detecci√≥n**: Distancia > umbral = an√≥malo
   - **Fortaleza**: Muy r√°pido, ideal para streaming

2. **LocalOutlierFactor** (Densidad)
   - **Prop√≥sito**: Detecta puntos con densidad local baja
   - **Detecci√≥n**: Sensible a anomal√≠as sutiles
   - **Fortaleza**: Capta patrones complejos

3. **OneClassSVM** (Frontera de decisi√≥n)
   - **Prop√≥sito**: Delimita regi√≥n "normal" con kernel lineal
   - **Detecci√≥n**: Puntos fuera de regi√≥n = an√≥malos
   - **Fortaleza**: Robusto en dimensiones moderadas

**Decisi√≥n final**: Promedio de scores ‚Üí `ml_low/medium/high_risk`

#### 3. Entrenamiento Continuo en Background

```python
# Hilo separado que reentrena cada 30s
def background_training():
    while True:
        if len(training_window) > 50:  # Datos suficientes
            train_models()
            save_models()  # Persistencia con joblib
        time.sleep(TRAINING_INTERVAL)
```

**Caracter√≠sticas clave:**
- **Ventana deslizante**: Solo √∫ltimos 1000 samples para adaptarse
- **Persistencia**: Modelos se guardan en `/tmp/models` 
- **Baseline autom√°tico**: Si no hay modelos, genera datos sint√©ticos para iniciar
- **Thread seguro**: Usa locks para evitar conflictos

#### 4. M√©tricas Detalladas para Observabilidad

El detector emite m√©tricas ricas para monitoreo:

```prometheus
# Amenazas por tipo espec√≠fico
ml_detector_port_scan_total{severity="high"} 15
ml_detector_ddos_total{attack_type="volumetric"} 3
ml_detector_syn_flood_total{severity="medium"} 8

# M√©tricas generales
ml_detector_threats_total{threat_type="ml_high_risk",confidence_level="high"} 12
ml_detector_processing_seconds_bucket{le="0.1"} 1247  # Latencia

# Estado de modelos
ml_detector_model_accuracy{model="kmeans"} 0.91
ml_detector_threat_confidence{threat_type="port_scan"} 0.87
```

## Fundamentos: Las Tecnolog√≠as que Hacen la Magia Posible

### eBPF: Tu "Microscopio" del Kernel Linux

Piensa en **eBPF** como un microscopio s√∫per potente que puede observar lo que pasa dentro del kernel Linux sin romper nada. 

**¬øC√≥mo funciona en t√©rminos simples?**
- Es una "m√°quina virtual segura" que vive **dentro** del kernel
- Ejecuta peque√±os programas que pueden "espiar" el tr√°fico de red, llamadas del sistema, etc.
- **Seguridad garantizada**: Linux verifica que el programa no pueda crashear el sistema
- **Rendimiento extremo**: Acceso directo a datos sin copiarlos m√∫ltiples veces

**Analog√≠a**: Es como tener un fot√≥grafo profesional tomando fotos perfectas del tr√°fico en una autopista, sin crear ning√∫n embotellamiento.

### XDP: La Primera L√≠nea de Defensa  

**XDP (Express Data Path)** es el punto m√°s temprano donde podemos "interceptar" un paquete de red:

```
Internet ‚Üí Tarjeta de Red ‚Üí XDP (AQU√ç!) ‚Üí Stack TCP/IP ‚Üí Aplicaci√≥n
```

**¬øPor qu√© es importante?**
- Procesa paquetes **antes** de que lleguen al sistema operativo
- Velocidad m√°xima: hasta 20+ millones de paquetes por segundo
- En nuestro proyecto: **solo observa, no bloquea** (modo pasivo)

### Ring Buffer: El T√∫nel de Datos Ultrarr√°pido

El **ring buffer** es como una cinta transportadora s√∫per eficiente entre el kernel y nuestra aplicaci√≥n Go:

```
Kernel (eBPF) ‚Üí [Ring Buffer] ‚Üí Go App
   Productor       256KB         Consumidor
```

**Ventajas vs. m√©todos tradicionales:**
- **10x menos latencia** que `perf_event`
- **Sin p√©rdida de datos** bajo alta carga  
- **Memoria compartida**: sin copiar datos innecesariamente

### M√©tricas de Red: Los "S√≠ntomas" que Analizamos

Nuestro sistema rastrea estas se√±ales clave:

| M√©trica | Qu√© Significa | Cu√°ndo es Sospechoso |
|---------|---------------|---------------------|
| **PPS** (Packets/sec) | Volumen de tr√°fico | >1000 puede ser DDoS |
| **BPS** (Bytes/sec) | Ancho de banda usado | Picos s√∫bitos = exfiltraci√≥n |
| **SYN Packets** | Intentos de conexi√≥n | >500/sec = SYN Flood |
| **IPs √önicas** | Diversidad de fuentes | >30 con alto PPS = port scan |
| **TCP Ratio** | % tr√°fico TCP vs total | >95% = tr√°fico muy dirigido |

### Por qu√© y c√≥mo se usa aqu√≠
- eBPF en XDP da telemetr√≠a casi en tiempo real con impacto m√≠nimo, ideal para derivar features simples pero informativas.
- `ringbuf.Reader` consume eventos, actualiza m√©tricas y ventanas; cada `POST_INTERVAL` se env√≠a un snapshot estable a ML.
- Estas features alimentan reglas r√°pidas + ensamble de modelos no supervisados en `ml-detector` para cubrir patrones conocidos y desconocidos.

### Modelos ML: prop√≥sito y elecci√≥n
- MiniBatchKMeans (clustering): modela lo ‚Äúnormal‚Äù en centros; distancia al centroide = rareza.
  - Pros: r√°pido, apto para streaming; capta macro-patrones de carga.
  - Contras: asume clusters aproximadamente esf√©ricos; requiere escalado (se usa `StandardScaler`).
- Local Outlier Factor (LOF, novelty): detecta puntos con densidad local baja frente a vecinos.
  - Pros: sensible a anomal√≠as locales (p. ej., subida de puertos √∫nicos sin gran BPS).
  - Contras: par√°metros a calibrar; coste > KMeans.
- One-Class SVM (kernel lineal): delimita la regi√≥n ‚Äúnormal‚Äù y marca lo externo como novedad.
  - Pros: robusto en dimensiones moderadas, lineal = r√°pido.
  - Contras: sensible a outliers en entrenamiento; necesita datos escalados.
- Ensamble y decisi√≥n: se promedian scores normalizados (KMeans/LOF/SVM) ‚Üí `ANOMALY_SCORE` y se discretiza en `ml_{low,medium,high}_risk`. En paralelo, reglas determin√≠sticas (`port_scan`, `ddos`, `data_exfiltration`, `syn_flood`) aportan explicabilidad inmediata.
- Entrenamiento/deriva: reentrenos peri√≥dicos sobre ventana deslizante; persistencia con `joblib` en `MODEL_PATH`. Si no hay modelos, se siembra baseline sint√©tico; ajustar umbrales con tr√°fico real para reducir falsos positivos.

### Flujo extremo a extremo
1) eBPF Monitor observa el tr√°fico y expone m√©tricas; adem√°s postea features al detector.
2) ML Detector combina reglas + modelos y devuelve un veredicto con confianza; emite m√©tricas por cada alerta.
3) Prometheus scrapea `/metrics` de ambos. Las reglas en Helm pueden disparar `PrometheusRule` (ej. ‚ÄúThreatDetected‚Äù, ‚ÄúPortScanDetected‚Äù). Grafana muestra paneles JSON embebidos en el chart.

### Probarlo r√°pido
- Bootstrap: `make bootstrap` y luego `make port-forward` para abrir Grafana/Prometheus/servicios.
- Salud r√°pida:
  - `curl -fsS http://localhost:8800/health` (ebpf-monitor)
  - `curl -fsS http://localhost:5000/health` (ml-detector)
- Detecci√≥n manual:
  - `curl -X POST :5000/detect -H 'content-type: application/json' -d '{"packets_per_second":1200,"bytes_per_second":1500000,"unique_ips":30,"unique_ports":50,"tcp_ratio":0.95,"syn_packets":800}'`
- Observabilidad:
  - Prometheus: `http://localhost:9090` (consulta `ml_detector_threats_total` y `ebpf_packets_per_second`).
  - Grafana: dashboards de seguridad incluidos en el chart principal (`helm/charts/ebpf-ai/grafana/*.json`).

### Dise√±o opinado y siguientes pasos
- Separaci√≥n de responsabilidades: Go para captura a bajo nivel; Python para decisiones y ML.
- M√©tricas primero: todo emite se√±ales cuantificables; f√°cil de alertar y depurar.
- Acoplado por HTTP + Prometheus: sustituible y escalable (ServiceMonitor opcional en Helm).
- Pr√≥ximos pasos sugeridos: afinar umbrales con datos reales, a√±adir features de flujo (duraci√≥n/ratio conexiones), y entrenamientos batch con muestras etiquetadas.

### Diagrama (ASCII)

```
        Tr√°fico
          ‚îÇ
          ‚ñº
   [XDP eBPF prog]
          ‚îÇ  (ringbuf events)
          ‚ñº
   ebpf-monitor (Go)
      ‚îú‚îÄ‚îÄ /metrics  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îú‚îÄ‚îÄ /health   ‚îÄ‚îÄ‚îê          ‚îÇ scrape
      ‚îî‚îÄ‚îÄ ‚Üí POST /detect (ML)    ‚îÇ
                                 ‚ñº
        ml-detector (Flask/ML)  /metrics
                 ‚îÇ                  ‚îÇ
                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
                         ‚ñº          ‚ñº
                      Prometheus  ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                         ‚îÇ
                         ‚ñº
                        Grafana (dashboards)

   (Deploy y sync v√≠a Argo CD; charts Helm en repo)
```

### Consultas PromQL √∫tiles
- Amenazas por tipo (√∫ltimos 15m):
  - `sum by (threat_type)(increase(ml_detector_threats_total[15m]))`
- Top 5 amenazas recientes:
  - `topk(5, sum by (threat_type)(increase(ml_detector_threats_total[30m])))`
- Latencia p95 del detector:
  - `histogram_quantile(0.95, sum by (le)(rate(ml_detector_processing_seconds_bucket[5m])))`
- Tr√°fico actual desde eBPF:
  - `ebpf_packets_per_second`
  - `ebpf_bytes_per_second`
- Reboots/errores del eBPF monitor:
  - `rate(ebpf_ringbuf_lost_events_total[5m])`

Sugerencias de paneles (Grafana):
- Timeseries de `ml_detector_threats_total` por `threat_type` con transform ‚Äúrate()‚Äù y leyenda por etiqueta.
- Gauge para `ebpf_packets_per_second` y `ebpf_bytes_per_second` con umbrales.
- Tabla de ‚ÄúTop threats‚Äù usando `topk()` con `increase()` en 30 min.
- Heatmap de latencia con `ml_detector_processing_seconds_bucket` y `histogram_quantile()` para p50/p95/p99.
