---
- name: Create ArgoCD namespace
  kubernetes.core.k8s:
    name: "{{ argocd.namespace }}"
    api_version: v1
    kind: Namespace
    state: present
    
- name: Add ArgoCD Helm repository
  kubernetes.core.helm_repository:
    name: argo
    repo_url: https://argoproj.github.io/argo-helm
    
- name: Install ArgoCD via Helm
  kubernetes.core.helm:
    name: argocd
    chart_ref: argo/argo-cd
    chart_version: "{{ argocd.version }}"
    release_namespace: "{{ argocd.namespace }}"
    values:
      configs:
        params:
          server.insecure: true  # For local development
        cm:
          admin.enabled: "true"
        secret:
          # bcrypt hash for "admin123"
          argocdServerAdminPassword: "$2y$05$CwRbzWIwJRy0vAeVBjFhvOhaEceMwEl/2VQpJUqMotipPr00u1yiW"
          # RFC3339 time to force reload of admin password
          argocdServerAdminPasswordMtime: "{{ lookup('pipe','date -u +%Y-%m-%dT%H:%M:%SZ') }}"
      server:
        service:
          type: "{{ 'LoadBalancer' if deployment_mode.type == 'prod' else 'NodePort' }}"
        ingress:
          enabled: false
      repoServer:
        env:
          - name: HTTP_PROXY
            value: "{{ argocd.http_proxy | default('') }}"
          - name: HTTPS_PROXY
            value: "{{ argocd.https_proxy | default('') }}"
          - name: NO_PROXY
            value: "{{ argocd.no_proxy | default('127.0.0.1,localhost,.svc,.cluster.local,kubernetes.default.svc') }}"
      controller:
        env:
          - name: HTTP_PROXY
            value: "{{ argocd.http_proxy | default('') }}"
          - name: HTTPS_PROXY
            value: "{{ argocd.https_proxy | default('') }}"
          - name: NO_PROXY
            value: "{{ argocd.no_proxy | default('127.0.0.1,localhost,.svc,.cluster.local,kubernetes.default.svc') }}"
      dex:
        enabled: false  # Disable for simplicity
      notifications:
        enabled: false
      applicationSet:
        enabled: true
    wait: false
    
- name: Wait for ArgoCD pods to be running
  kubernetes.core.k8s_info:
    api_version: v1
    kind: Pod
    namespace: "{{ argocd.namespace }}"
    label_selectors:
      - app.kubernetes.io/part-of=argocd
    wait: true
    wait_condition:
      type: Ready
      status: "True"
    wait_timeout: 300
    
- name: Get ArgoCD server service information
  kubernetes.core.k8s_info:
    api_version: v1
    kind: Service
    name: argocd-server
    namespace: "{{ argocd.namespace }}"
  register: argocd_service
  
# Git Repository Access Configuration
#
# DEVELOPMENT/PUBLIC REPOS: Uses HTTPS (current configuration)
#   - No SSH keys required
#   - Suitable for public repositories
#   - Simpler setup and more secure for public projects
#
# PRODUCTION/PRIVATE REPOS: Use SSH (manual configuration required)
#   - For private repositories that require SSH access
#   - Configure manually after bootstrap:
#     kubectl create secret generic git-ssh-key \
#       --from-file=ssh-privatekey=~/.ssh/id_ed25519 \
#       --from-file=ssh-publickey=~/.ssh/id_ed25519.pub \
#       -n argocd
#   - Then add label: kubectl label secret git-ssh-key argocd.argoproj.io/secret-type=repository -n argocd
#   - Update applications to use: repoURL: "git@github.com:user/repo.git"
  
- name: Create ArgoCD Ingress for UI access
  kubernetes.core.k8s:
    definition:
      apiVersion: networking.k8s.io/v1
      kind: Ingress
      metadata:
        name: argocd-server-ingress
        namespace: "{{ argocd.namespace }}"
        annotations:
          nginx.ingress.kubernetes.io/ssl-passthrough: "true"
          nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
          nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
      spec:
        ingressClassName: nginx
        rules:
        - host: argocd.local
          http:
            paths:
            - path: /
              pathType: Prefix
              backend:
                service:
                  name: argocd-server
                  port:
                    number: 443
        - http:
            paths:
            - path: /argocd
              pathType: Prefix
              backend:
                service:
                  name: argocd-server
                  port:
                    number: 443
    state: present

- name: Create Kubernetes Dashboard Ingress
  kubernetes.core.k8s:
    definition:
      apiVersion: networking.k8s.io/v1
      kind: Ingress
      metadata:
        name: kubernetes-dashboard-ingress
        namespace: kubernetes-dashboard
        annotations:
          nginx.ingress.kubernetes.io/ssl-passthrough: "true"
          nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
          nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
      spec:
        ingressClassName: nginx
        rules:
        - host: dashboard.local
          http:
            paths:
            - path: /
              pathType: Prefix
              backend:
                service:
                  name: kubernetes-dashboard
                  port:
                    number: 443
        - http:
            paths:
            - path: /dashboard
              pathType: Prefix
              backend:
                service:
                  name: kubernetes-dashboard
                  port:
                    number: 443
    state: present
  
- name: Display ArgoCD access information
  debug:
    msg:
      - "üöÄ ArgoCD GitOps installed successfully!"
      - "üåê Access URL: Use port-forward (LoadBalancer pending in Minikube)"
      - "üë§ Username: admin"
      - "üîê Password: admin123"
      - "üí° Port forward: kubectl port-forward svc/argocd-server -n argocd 8080:80"
- name: Add required Helm repositories for dependencies
  kubernetes.core.helm_repository:
    name: "{{ item.name }}"
    repo_url: "{{ item.url }}"
  loop:
    - name: bitnami
      url: https://charts.bitnami.com/bitnami
    - name: grafana  
      url: https://grafana.github.io/helm-charts
    - name: prometheus-community
      url: https://prometheus-community.github.io/helm-charts

- name: Build Helm chart dependencies for eBPF AI
  command: helm dependency build
  args:
    chdir: "/Users/jeanlopez/ebpf-ia-gitops/helm/charts/ebpf-ai"
  register: helm_deps
  changed_when: helm_deps.rc == 0

- name: Wait for ArgoCD to be fully ready
  kubernetes.core.k8s_info:
    api_version: v1
    kind: Pod
    namespace: "{{ argocd.namespace }}"
    label_selectors:
      - app.kubernetes.io/name=argocd-server
    wait: true
    wait_condition:
      type: Ready
      status: "True"
    wait_timeout: 300
    
# Password configured via Helm values during installation
    
- name: Apply App-of-Apps pattern
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: argoproj.io/v1alpha1
      kind: Application
      metadata:
        name: ebpf-ai-apps
        namespace: "{{ argocd.namespace }}"
        labels:
          app.kubernetes.io/name: ebpf-ai-apps
          app.kubernetes.io/part-of: ebpf-ai-system
      spec:
        project: default
        source:
          repoURL: "{{ applications.ebpf_ai.git_repo }}"
          targetRevision: "{{ applications.ebpf_ai.git_branch }}"
          path: gitops/applications
        destination:
          server: https://kubernetes.default.svc
          namespace: "{{ argocd.namespace }}"
        syncPolicy:
          automated:
            prune: true
            selfHeal: true
            allowEmpty: false
          syncOptions:
            - CreateNamespace=true
            - PrunePropagationPolicy=foreground
            - PruneLast=true
          retry:
            limit: 5
            backoff:
              duration: 5s
              factor: 2
              maxDuration: 3m
              
- name: Create eBPF AI Application
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: argoproj.io/v1alpha1
      kind: Application
      metadata:
        name: ebpf-ai
        namespace: "{{ argocd.namespace }}"
        labels:
          app.kubernetes.io/name: ebpf-ai
          app.kubernetes.io/part-of: ebpf-ai-system
        finalizers:
          - resources-finalizer.argocd.argoproj.io
      spec:
        project: default
        source:
          repoURL: "{{ applications.ebpf_ai.git_repo }}"
          targetRevision: "{{ applications.ebpf_ai.git_branch }}"
          path: "{{ applications.ebpf_ai.git_path }}"
          helm:
            valueFiles:
              - values.yaml
            parameters:
              - name: global.namespace
                value: "{{ applications.ebpf_ai.namespace }}"
              - name: mlDetector.replicaCount
                value: "{{ resources.ml_detector.replicas }}"
              - name: autoscaling.enabled
                value: "true"
              - name: redis.enabled
                value: "true"
              - name: prometheus.enabled
                value: "true"
              - name: grafana.enabled
                value: "true"
        destination:
          server: https://kubernetes.default.svc
          namespace: "{{ applications.ebpf_ai.namespace }}"
        syncPolicy:
          automated:
            prune: true
            selfHeal: true
            allowEmpty: false
          syncOptions:
            - CreateNamespace=true
            - PrunePropagationPolicy=foreground
            - PruneLast=true
          retry:
            limit: 5
            backoff:
              duration: 5s
              factor: 2
              maxDuration: 3m
        revisionHistoryLimit: 10
        
- name: Wait for ArgoCD application to be created
  kubernetes.core.k8s_info:
    api_version: argoproj.io/v1alpha1
    kind: Application
    name: ebpf-ai
    namespace: "{{ argocd.namespace }}"
    wait: true
    wait_timeout: 60
    
- name: Display GitOps setup status
  debug:
    msg:
      - "üöÄ ArgoCD Applications configured successfully!"
      - "üìã App-of-Apps: ebpf-ai-apps"
      - "ü§ñ Main Application: ebpf-ai"
      - "üîÑ Sync Policy: Automated (prune + self-heal enabled)"
      - "üì¶ Git Repository: {{ applications.ebpf_ai.git_repo }}"
      - "üåø Branch: {{ applications.ebpf_ai.git_branch }}"
