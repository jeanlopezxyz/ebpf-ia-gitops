package main

import (
    "bytes"
    "encoding/binary"
    "fmt"
    "log"
    "net"
    "os"
    "os/signal"
    "strings"
    "syscall"
    "time"

    "github.com/cilium/ebpf"
    "github.com/cilium/ebpf/link"
    "github.com/cilium/ebpf/ringbuf"
    "github.com/cilium/ebpf/rlimit"

    cfgpkg "github.com/jeanlopezxyz/ebpf-ia-gitops/applications/ebpf-monitor/pkg/config"
    httpserver "github.com/jeanlopezxyz/ebpf-ia-gitops/applications/ebpf-monitor/pkg/httpserver"
    met "github.com/jeanlopezxyz/ebpf-ia-gitops/applications/ebpf-monitor/pkg/metrics"
    ml "github.com/jeanlopezxyz/ebpf-ia-gitops/applications/ebpf-monitor/pkg/mlclient"
    proc "github.com/jeanlopezxyz/ebpf-ia-gitops/applications/ebpf-monitor/pkg/processor"
)

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc clang -cflags "-O2 -Wall" network ../../bpf/network_monitor.c

// Global readiness flag
var ready bool

// Local copy of the event struct encoded by the eBPF program
type NetworkEvent struct {
    SrcIP      uint32
    DstIP      uint32
    SrcPort    uint16
    DstPort    uint16
    Protocol   uint8
    PacketSize uint32
    Timestamp  uint64
    TCPFlags   uint8
}

func ipToString(ip uint32) string {
	return fmt.Sprintf("%d.%d.%d.%d",
		byte(ip), byte(ip>>8), byte(ip>>16), byte(ip>>24))
}

// isRingbufClosed checks if the ringbuf error indicates it's closed
func isRingbufClosed(err error) bool {
	return strings.Contains(err.Error(), "closed") || strings.Contains(err.Error(), "EOF")
}

// processEvent now is handled by processor package; we keep a thin adapter
func toProcEvent(e NetworkEvent) proc.NetworkEvent {
    return proc.NetworkEvent{SrcIP: e.SrcIP, DstIP: e.DstIP, SrcPort: e.SrcPort, DstPort: e.DstPort, Protocol: e.Protocol, PacketSize: e.PacketSize, Timestamp: e.Timestamp, TCPFlags: e.TCPFlags}
}

func runEBPF(ifName string, input chan<- proc.NetworkEvent) (*ebpf.Map, error) {
    // Remove memory limit for eBPF
    if err := rlimit.RemoveMemlock(); err != nil {
        return nil, fmt.Errorf("removing memlock: %w", err)
    }

	// Try to load eBPF program (generated by bpf2go)
    spec, err := loadNetworkSpecs()
    if err != nil {
        // Fallback to simulation mode handled by caller
        return nil, fmt.Errorf("cannot load eBPF: %w", err)
    }

    coll, err := ebpf.NewCollection(spec)
    if err != nil {
        return nil, fmt.Errorf("creating eBPF collection: %w", err)
    }
    // keep collection open for process lifetime

	// Attach to network interface
	prog := coll.Programs["network_monitor"]
    log.Printf("Trying to attach to interface: %s", ifName)
    iface, err := net.InterfaceByName(ifName)
    if err != nil {
        log.Printf("Interface %s not found, trying fallbacks", ifName)
        // Try some common interfaces
        fallbacks := []string{"lo", "cilium_host", "cni0"}
        for _, name := range fallbacks {
            iface, err = net.InterfaceByName(name)
            if err == nil {
                log.Printf("Using fallback interface: %s", name)
                break
            }
        }
        if err != nil {
            return nil, fmt.Errorf("no suitable interface found (tried: %s, %v)", ifName, fallbacks)
        }
    }

	l, err := link.AttachXDP(link.XDPOptions{
		Program:   prog,
		Interface: iface.Index,
	})
    if err != nil {
        return nil, fmt.Errorf("attaching XDP: %w", err)
    }
    // keep link open for process lifetime
    _ = l  // prevent unused variable error

	// Open ring buffer for events
    rd, err := ringbuf.NewReader(coll.Maps["events"])
    if err != nil {
        return nil, fmt.Errorf("opening ringbuf: %w", err)
    }
    // keep reader open for process lifetime

    log.Printf("✅ eBPF program attached to %s", iface.Name)

    // Read events asynchronously
    go func() {
        log.Printf("Starting ring buffer reader loop...")
        for {
            record, err := rd.Read()
            if err != nil {
                if isRingbufClosed(err) {
                    log.Printf("Ring buffer closed, stopping reader")
                    return
                }
                log.Printf("Error reading from ring buffer: %v", err)
                met.RingbufLostEventsTotal.Inc()
                time.Sleep(100 * time.Millisecond)
                continue
            }

            var event NetworkEvent
            if err := binary.Read(bytes.NewReader(record.RawSample), binary.LittleEndian, &event); err != nil {
                log.Printf("Error parsing event: %v", err)
                continue
            }
            input <- toProcEvent(event)
        }
    }()

    // return pointer to unique port map if present
    portMap, _ := coll.Maps["port_unique_count"]
    return portMap, nil
}

func simulateTraffic(input chan<- proc.NetworkEvent) {
    // Simulation mode when eBPF is not available
    ticker := time.NewTicker(100 * time.Millisecond)
    defer ticker.Stop()

    for range ticker.C {
        event := NetworkEvent{
            SrcIP:      uint32(0x0A000001 + time.Now().Unix()%255),
            DstIP:      uint32(0x0A000002),
            SrcPort:    uint16(1024 + time.Now().Unix()%60000),
            DstPort:    uint16(80 + time.Now().Unix()%3),
            Protocol:   uint8(6),
            PacketSize: uint32(64 + time.Now().Unix()%1400),
            Timestamp:  uint64(time.Now().UnixNano()),
        }
        input <- toProcEvent(event)
    }
}

// Helper functions for eBPF (loadNetwork is generated by bpf2go)

func isRingbufClosed(err error) bool {
    // Check for various ringbuf closed conditions
    if err == nil {
        return false
    }
    errStr := err.Error()
    return errStr == "closed" || 
           errStr == "reader closed" || 
           errStr == "ringbuffer: file already closed" ||
           strings.Contains(errStr, "file already closed") ||
           strings.Contains(errStr, "use of closed")
}

func main() {
    cfg := cfgpkg.New()
    met.Register()

    // Processor and ML client
    pr := proc.New(cfg.StatsWindow, 4096)
    pr.Start()
    ml.New(cfg, pr.Stats).Start()

    // eBPF or simulation
    input := pr.Input()
    portMap, err := runEBPF(cfg.Interface, input)
    if err != nil {
        log.Printf("⚠️  Cannot load eBPF (need root/CAP_BPF or bpf2go generation failed). Running in simulation mode: %v", err)
        go simulateTraffic(input)
        ready = true
    } else {
        ready = true
    }

    // If BPF unique port map is available, sum values periodically
    if portMap != nil {
        go func() {
            ticker := time.NewTicker(cfg.StatsWindow)
            defer ticker.Stop()
            for range ticker.C {
                var sum uint64
                it := portMap.Iterate()
                var k uint32
                var v uint32
                for it.Next(&k, &v) {
                    sum += uint64(v)
                }
                met.BPFUniquePorts.Set(float64(sum))
            }
        }()
    }

    // Function to dump BPF unique ports per IP for debug
    var dump func() any
    if portMap != nil {
        dump = func() any {
            type item struct{ IP string `json:"ip"`; Count uint32 `json:"count"` }
            out := []item{}
            it := portMap.Iterate()
            var k uint32
            var v uint32
            for it.Next(&k, &v) {
                out = append(out, item{IP: ipToString(k), Count: v})
            }
            return out
        }
    }

    // HTTP server with timeouts + readiness
    srv := httpserver.New(cfg.HTTPAddr, cfg.ReadHeaderTimeout, cfg.ReadTimeout, cfg.WriteTimeout, cfg.IdleTimeout, pr.Stats, func() bool { return ready }, dump)

    // graceful shutdown on SIGINT/SIGTERM
    done := make(chan struct{})
    go func() {
        if err := srv.Start(); err != nil {
            log.Printf("http server stopped: %v", err)
        }
        close(done)
    }()
    sigCh := make(chan os.Signal, 1)
    signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
    <-sigCh
    _ = srv.Shutdown()
}
